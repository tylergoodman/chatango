import { EventEmitter } from 'events';
import * as Promise from 'bluebird';
import User from './User';
import Message from './Message';
export interface RoomOptions {
    auto_reconnect?: boolean;
    message_cache_size?: number;
}
export declare class Room extends EventEmitter implements RoomOptions {
    name: string;
    user: User;
    hostname: string;
    id: string;
    session_id: string;
    owner: string;
    ip: string;
    server_time: number;
    here_now: number;
    moderators: Set<string>;
    users: Map<string, User>;
    auto_reconnect: boolean;
    message_cache_size: number;
    private _socket;
    private _ping;
    private _buffer;
    private _first_send;
    private _disconnecting;
    private _connecting;
    private _history;
    private _last_message;
    private static TIMEOUT;
    private static RECONNECT_DELAY;
    private static PING_TIMEOUT;
    private static PORT;
    private static COMMAND_PREFIX;
    private static DEFAULT_OPTIONS;
    readonly identifier: string;
    static getHostname(room_name: string): string;
    constructor(name: string, user?: User, options?: RoomOptions);
    private _initSocket();
    private _handleClose(had_error);
    private _handleData(data);
    private _handleDrain();
    private _handleConnect();
    private _handleEnd();
    private _handleError(err);
    private _handleLookup(err, address, family);
    private _startPing();
    private _stopPing();
    private _resetPing();
    private _reconnect();
    private _reset();
    private _send(request, restartPing?);
    private _userlist_get();
    private _auth();
    private _join();
    private _find_user_by_id(connection_id);
    connect(port?: number, connectListener?: Function): Promise<Room>;
    disconnect(): Promise<Room>;
    message(content: string): Room;
    delete(message: Message): Room;
    deleteAll(user: Message | User): Room;
    ban(user: Message | User): Room;
    unban(user: Message | User): Room;
    __command__ok(owner: string, session_id: string, session_status: string, username: string, server_time: string, ip: string, moderators: string, server_id: string): void;
    __command__i(): void;
    __command__nomore(): void;
    __command__inited(): void;
    __command__pwdok(): void;
    __command__aliasok(): void;
    __command__relogin(): void;
    __command__denied(): void;
    __command__badlogin(): void;
    __command__n(num_users: string): void;
    __command__b(): void;
    __command__u(old_id: string, new_id: string): void;
    __command__mods(modlist: string): void;
    __command__gparticipants(num_unregistered: string, ...users: string[]): void;
    __command__participant(status: string, connection_id: string, session_id: string, user_registered: string, user_temporary: string, no_idea: string, joined_at: string): void;
    __command__badalias(): void;
    __command__show_nlp(): void;
    __command__nlptb(): void;
    __command__show_fw(): void;
    __command__show_tb(seconds: string): void;
    __command__tb(seconds_remaining: string): void;
    __command__climited(server_time: string, ...request: string[]): void;
    __command__delete(message_id: string): void;
    __command__deleteall(...message_ids: string[]): void;
    __command__blocked(id: string, ip: string, name: string, session_id: string, server_time: string): void;
    __command__unblocked(id: string, ip: string, name: string, session_id: string, server_time: string): void;
    private _parseMessage(created_at, user_registered, user_temporary, user_session_id, user_id, message_id, user_ip, no_idea, no_idea2, ...raw_message);
}
export default Room;
